{"./":{"url":"./","title":"介绍","keywords":"","body":"Tutorial For Front End Engineer 前端工程师入门指南 This is a tutorial for most front end engineer written by Tusi. You can click the menu icon for more chapters. I would be honored if this book could help you. "},"doc/块级元素和行内元素.html":{"url":"doc/块级元素和行内元素.html","title":"块级元素和行内元素","keywords":"","body":"title 块级元素 块级元素占据独立的空间，有以下特点： 独占一行或多行 宽度，高度，内外边距可以设置，且有效 宽度默认是父容器的100% 可以作为其他块级元素和行内元素的父容器（文本类块级元素不建议作为其他块级元素的容器，如p, h1~h6） 常见的块级元素有：div, h1~h6, hgroup, p, table, form, ul, ol, hr, header, main, footer, aside, article, section, video, audio, canvas, pre, option 行内元素 行内元素不占据独立空间，依靠自身内容撑开宽高，与同属一个父容器的其他行内元素在同一行上依次排列，根据white-space属性值来决定是否换行。它们具备以下特征： 不独占一行，但内容过长时会根据white-space控制换行。 宽度，高度的设置是无效的。内外边距只能设置左右方向（设置padding-top, padding-bottom, margin-top, margin-bottom是无效的）。但是有一点要注意，padding-top和padding-bottom对自身有表现效果，但是不影响周围元素的布局，看图说话： 宽度由自身内容决定。 行内元素不建议作为块级元素的容器（a标签例外） 常见的行内元素有：span, i, code, strong, a, br, sub, sup, label 对于不确定的元素，可以设置width来测试下，如果width不生效，说明是行内元素啦。 行内块级元素 行内块级元素也不会独占一行，但是可设置宽高，内外边距等。 常见的行内块级元素有：input， button, img, select, textarea CSS显示转换 display: block; 让元素表现为块级元素 display: inline; 让元素表现为行内元素 display: inline-block; 让元素表现为行内块级元素 var gitalk = new Gitalk({ clientID: \"c17498a9a9fa6e17b36a\", clientSecret: \"556df0480f8f48e142432f50273ea149cf206c07\", repo: \"https://github.com/cumt-robin/FE-learning\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname).length }); gitalk.render(\"gitalk-container\"); "},"doc/耐人寻味的CSS属性white-space.html":{"url":"doc/耐人寻味的CSS属性white-space.html","title":"耐人寻味的CSS属性white-space","keywords":"","body":"概述 《耐人寻味的CSS属性white-space》，本文说的white-space是一个控制换行和空白处理的CSS属性。我曾经被这个属性烦死，一直没记住，今天决定还是写下来好好琢磨下。 属性值 normal 默认值，正常换行，空白和换行符会被浏览器忽略。啥意思呢？ 正常换行的意思是，单词间会正常换行，如果下一个单词太长，不足以在当前行剩余部分完整展示，则会在下一行显示。哪些情况算一个单词呢？ 一个中文字 一个英文单词 // 这是两个单词 Tusi Blog // 这只算一个单词 TusiBlog 连续的数字或符号也只算一个单词 // 这只算一个单词，如果超长也不会换行，会挤出横向滚动条 10000000000000000000000+2000000000000000000*200000000000000 空白和换行符会被浏览器忽略。就是你输入连续的空格，只会表现出一个空格的效果；如果敲了回车，也不会换行。 00000000 00000000000000000> 00000000 00000000000000000 pre 行为方式类似HTML中的pre标签。pre标签一般用来包裹源代码。 不会自动换行（想想，你写代码时，不回车会换行吗？），除非在文本中遇到换行符（敲了回车）或使用了br标签。 空白会被浏览器保留。意思就是连续的空格会被保留，不会合并成一个。 nowrap 不换行，内容再多也不换行。 忽略换行符，也就是说回车也不会换行，直到遇到br标签为止。 pre-wrap 正常换行 连续的空白符会被保留 换行符（回车）也是有效的 pre-line 正常换行 连续空白符会被合并成一个 换行符（回车）也有效 inherit 继承父元素的white-space属性值 总结 可以从几个方面来对比下这几种属性值的差异。 是否正常换行 是否合并连续空白符 换行符是否有效 normal 是 是 否 pre 否 否 是 nowrap 否 是 否 pre-wrap 是 否 是 pre-line 是 是 是 妈呀，还是挺难记的，多多复习！ "},"doc/耐人寻味的CSS属性font-family.html":{"url":"doc/耐人寻味的CSS属性font-family.html","title":"耐人寻味的CSS属性font-family","keywords":"","body":"概述 font-family是一个网站呈现给用户最佳体验的最直接的途径，因此有必要花功夫来研究一下。首先需要了解衬线字体和无衬线字体，接着了解中英文的常用字体及其适用性。 衬线字体 衬线的笔画有粗有细的变化，在每一笔画上都自有风格，笔画末端会有修饰，强调艺术感，适合用于博客，旅游，文化，艺术类网站。 无衬线字体 无衬线的字体工整方正，给人正式的感觉，适合政务类，企业类网站使用。 中文字体 Windows simsun，宋体，也是windows下大部分浏览器的默认字体，font-size较大时清晰度不佳。 Microsoft Yahei，无衬线字体，微软雅黑，是微软委托中国方正设计的一款中文字体。 Mac OS STHeiti，华文黑体，OS X 10.6之前的简体中文系统界面默认字体，也是目前Chrome游览器下的默认字体。 STXihei，华文细黑，比STHeiti文字更细。 Heiti SC，黑体-简，从 OS X 10.6 开始，黑体-简代替华文黑体用作简体中文系统界面默认字体，显示效果不错，但是喇叭口设计遭人诟病。 Hiragino Sans GB，冬青黑体，清新的专业印刷字体，小字号时足够清晰，拥有很多人的追捧。 PingFang SC，苹方，在Mac OS X EL Capitan上，苹果为中国用户打造，去掉了为人诟病的喇叭口 Linux WenQuanYi Micro Hei，文泉驿微米黑，Linux最佳简体中文字体。 英文字体 Windows Arial，无衬线西文字体，显示效果一般 Tahoma，无衬线字体，显示效果比Arial要好。 Verdana，无衬线字体，优点在于它在小字上仍结构清晰端整、阅读辨识容易。 Mac OS Times New Roman，衬线字体，Mac平台Safari下默认的字体。 Helvetica、Helvetica Neue，被广泛使用。 San Francisco，与苹方一样，mac os最新的西文字体 font-family设置原则 西文优先：西文字体中大多不包含中文，西文优先，中文紧随其后，这样就不会影响到中文字体的选择。 从新到旧：优先体验最好的字体，向下兼容 兼容多种操作系统：考虑windows, mac os, android, linux等系统 补充字体族：最后根据衬线serif或无衬线sans-serif来补充字体族，当所有设置的字体都找不到时，让操作系统有选择字体的方向。 font-family推荐 font-family: \"Helvetica Neue\", Helvetica, \"PingFang SC\", Tahoma, \"Hiragino Sans GB\", \"Heiti SC\", Arial, \"Microsoft YaHei\", \"WenQuanYi Micro Hei\", sans-serif; var gitalk = new Gitalk({ clientID: \"c17498a9a9fa6e17b36a\", clientSecret: \"556df0480f8f48e142432f50273ea149cf206c07\", repo: \"https://github.com/cumt-robin/FE-learning\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname).length }); gitalk.render(\"gitalk-container\"); "},"doc/原生js创建ajax请求的步骤.html":{"url":"doc/原生js创建ajax请求的步骤.html","title":"原生js创建ajax请求的步骤","keywords":"","body":"创建 XMLHttpRequest 对象 // 兼容写法 if (window.XMLHttpRequest) { // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); } else { // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); } 设置请求的类型，URL以及是否异步(async) xmlhttp.open(\"GET\", \"/article/page\", true); xmlhttp.open(\"POST\", \"/article/add\", true); 备注： （1）当请求类型为GET时，传递的参数可直接放在URL的查询字符串中；POST请求的参数需要传入xmlhttp.send方法 （2）推荐设置async为true，使用异步的方式进行处理，需要通过onreadystatechange监听请求状态；如果async为false，则请求是同步的，就不需要监听请求状态了，直接在xmlhttp.send方法后写处理代码就可以了，但是同步请求是会阻塞的，此时浏览器看起来就像卡死了一样，没特殊情况千万别用同步请求。 设置请求头 xmlhttp.setRequestHeader(HTTP 头名称，HTTP请求头值)，举个示例： xmlhttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); 监听请求状态 xmlhttp.onreadystatechange= function(){ if (xmlhttp.readyState == 4 && xmlhttp.status == 200) { // 请求成功，进行业务处理 // ...... } } 备注： readyState有五种状态： 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 我们主要关注状态4 发送请求 xmlhttp.send()，该方法可以携带POST请求的参数，参数写法也是查询字符串格式，示例： xmlhttp.send('username=Tusi&password=999999') "},"doc/ajax设置超时及监听事件.html":{"url":"doc/ajax设置超时及监听事件.html","title":"ajax设置超时及监听超时事件","keywords":"","body":"设置超时时间 xhr.timeout = 2000; // 超时时间，单位是毫秒 监听超时 xhr.ontimeout = function (e) { // XMLHttpRequest超时，做超时的提示或其他处理。 }; "},"doc/ajax获取文件上传进度.html":{"url":"doc/ajax获取文件上传进度.html","title":"ajax获取文件上传进度","keywords":"","body":"示例代码 直接上代码： // 首先监听input框的变动，选中一个新的文件会触发change事件 document.querySelector(\"#file\").addEventListener(\"change\", function () { // 取得文件对象 var file = document.querySelector(\"#file\").files[0]; // 使用FormData保存文件数据 var formdata = new FormData(); formdata.append(\"file\", file); var xhr = new XMLHttpRequest(); xhr.open(\"post\", \"/upload\"); xhr.onreadystatechange = function () { if (xhr.readyState == 4 && xhr.status == 200) { // 上传完成 } } // 获取上传的进度 xhr.upload.onprogress = function (event) { if (event.lengthComputable) { // 计算出百分比 var percent = event.loaded / event.total * 100; // 修改进度条的宽度 document.querySelector(\"#progress\").style.width = percent + \"%\"; } } // 由于是post方式，文件数据formdata通过send方法进行传递 xhr.send(formdata); }); "}}