{"./":{"url":"./","title":"介绍","keywords":"","body":"Tutorial For Front End Engineer 前端工程师入门指南 This is a tutorial for frontend engineers written by Tusi. You can open the link and click the menu icon for more chapters. I would be honored if this book could help you. :camera: 前端基础知识 HTML 块级元素和行内元素 CSS 耐人寻味的CSS属性white-space 耐人寻味的CSS属性font-family Javascript Ajax 原生js创建ajax请求的步骤 ajax设置超时及监听超时事件 ajax获取文件上传进度 :chart_with_upwards_trend: 前端进阶 模块化 回头再看JS模块化编程 回头再看JS模块化编程之AMD sea.js的同步魔法 可能是最详细的UMD模块入门指南 原理性知识 渲染引擎 JS引擎 运行时环境 如何实现一个符合Promise/A+规范的Promise 框架 Vue vue项目中引入iconfont vue作用域插槽，你真的懂了吗 设计模式 从一道面试题简单谈谈发布订阅和观察者模式 架构 前端API层架构，也许你做得还不够 用初中数学知识撸一个canvas环形进度条 编译相关 入门babel，我们需要了解些什么 组件化/npm化 发布一个简单的npm包 跨平台 Hybrid cordova开发环境搭建 ionic初体验 浏览器hack 如何判断IE OCX插件正常安装 版本管理 Git Gerrit常见命令及最佳实践 部署/运维 shell 自动化部署的一小步，前端搬砖的一大步 "},"doc/块级元素和行内元素.html":{"url":"doc/块级元素和行内元素.html","title":"块级元素和行内元素","keywords":"","body":"块级元素 块级元素占据独立的空间，有以下特点： 独占一行或多行 宽度，高度，内外边距可以设置，且有效 宽度默认是父容器的100% 可以作为其他块级元素和行内元素的父容器（文本类块级元素不建议作为其他块级元素的容器，如p, h1~h6） 常见的块级元素有：div, h1~h6, hgroup, p, table, form, ul, ol, hr, header, main, footer, aside, article, section, video, audio, canvas, pre, option 行内元素 行内元素不占据独立空间，依靠自身内容撑开宽高，与同属一个父容器的其他行内元素在同一行上依次排列，根据white-space属性值来决定是否换行。它们具备以下特征： 不独占一行，但内容过长时会根据white-space控制换行。 宽度，高度的设置是无效的。内外边距只能设置左右方向（设置padding-top, padding-bottom, margin-top, margin-bottom是无效的）。但是有一点要注意，padding-top和padding-bottom对自身有表现效果，但是不影响周围元素的布局，看图说话： 宽度由自身内容决定。 行内元素不建议作为块级元素的容器（a标签例外） 常见的行内元素有：span, i, code, strong, a, br, sub, sup, label 对于不确定的元素，可以设置width来测试下，如果width不生效，说明是行内元素啦。 行内块级元素 行内块级元素也不会独占一行，但是可设置宽高，内外边距等。 常见的行内块级元素有：input， button, img, select, textarea CSS显示转换 display: block; 让元素表现为块级元素 display: inline; 让元素表现为行内元素 display: inline-block; 让元素表现为行内块级元素 var gitalk = new Gitalk({ clientID: \"c17498a9a9fa6e17b36a\", clientSecret: \"556df0480f8f48e142432f50273ea149cf206c07\", repo: \"FE-learning\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "},"doc/耐人寻味的CSS属性white-space.html":{"url":"doc/耐人寻味的CSS属性white-space.html","title":"耐人寻味的CSS属性white-space","keywords":"","body":"概述 《耐人寻味的CSS属性white-space》，本文说的white-space是一个控制换行和空白处理的CSS属性。我曾经被这个属性烦死，一直没记住，今天决定还是写下来好好琢磨下。 属性值 normal 默认值，正常换行，空白和换行符会被浏览器忽略。啥意思呢？ 正常换行的意思是，单词间会正常换行，如果下一个单词太长，不足以在当前行剩余部分完整展示，则会在下一行显示。哪些情况算一个单词呢？ 一个中文字 一个英文单词 // 这是两个单词 Tusi Blog // 这只算一个单词 TusiBlog 连续的数字或符号也只算一个单词 // 这只算一个单词，如果超长也不会换行，会挤出横向滚动条 10000000000000000000000+2000000000000000000*200000000000000 空白和换行符会被浏览器忽略。就是你输入连续的空格，只会表现出一个空格的效果；如果敲了回车，也不会换行。 00000000 00000000000000000> 00000000 00000000000000000 pre 行为方式类似HTML中的pre标签。pre标签一般用来包裹源代码。 不会自动换行（想想，你写代码时，不回车会换行吗？），除非在文本中遇到换行符（敲了回车）或使用了br标签。 空白会被浏览器保留。意思就是连续的空格会被保留，不会合并成一个。 nowrap 不换行，内容再多也不换行。 忽略换行符，也就是说回车也不会换行，直到遇到br标签为止。 pre-wrap 正常换行 连续的空白符会被保留 换行符（回车）也是有效的 pre-line 正常换行 连续空白符会被合并成一个 换行符（回车）也有效 inherit 继承父元素的white-space属性值 总结 可以从几个方面来对比下这几种属性值的差异。 是否正常换行 是否合并连续空白符 换行符是否有效 normal 是 是 否 pre 否 否 是 nowrap 否 是 否 pre-wrap 是 否 是 pre-line 是 是 是 妈呀，还是挺难记的，多多复习！ var gitalk = new Gitalk({ clientID: \"c17498a9a9fa6e17b36a\", clientSecret: \"556df0480f8f48e142432f50273ea149cf206c07\", repo: \"FE-learning\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "},"doc/耐人寻味的CSS属性font-family.html":{"url":"doc/耐人寻味的CSS属性font-family.html","title":"耐人寻味的CSS属性font-family","keywords":"","body":"概述 font-family是一个网站用户体验的第一入口，非常有必要花功夫来研究一下。我们首先需要了解衬线字体和无衬线字体，接着了解中英文的常用字体及其适用性。 衬线字体 衬线（serif）的笔画有粗有细的变化，在每一笔画上都自有风格，笔画末端会有修饰，强调艺术感，适合用于博客，旅游，文化，艺术类网站。 无衬线字体 无衬线（sans-serif）的字体工整方正，给人正式的感觉，适合政务类，企业类网站使用。 中文字体 Windows simsun，宋体，也是windows下大部分浏览器的默认字体，font-size较大时清晰度不佳。 Microsoft Yahei，无衬线字体，微软雅黑，是微软委托中国方正设计的一款中文字体。 Mac OS STHeiti，华文黑体，OS X 10.6之前的简体中文系统界面默认字体，也是目前Chrome游览器下的默认字体。 STXihei，华文细黑，比STHeiti文字更细。 Heiti SC，黑体-简，从 OS X 10.6 开始，黑体-简代替华文黑体用作简体中文系统界面默认字体，显示效果不错，但是喇叭口设计遭人诟病。 Hiragino Sans GB，冬青黑体，清新的专业印刷字体，小字号时足够清晰，拥有很多人的追捧。 PingFang SC，苹方，在Mac OS X EL Capitan上，苹果为中国用户打造，去掉了为人诟病的喇叭口。 Linux WenQuanYi Micro Hei，文泉驿微米黑，Linux最佳简体中文字体。 英文字体 Windows Arial，无衬线西文字体，显示效果一般。 Tahoma，无衬线字体，显示效果比Arial要好。 Verdana，无衬线字体，优点在于它在小字上仍结构清晰端整、阅读辨识容易。 Mac OS Times New Roman，衬线字体，Mac平台Safari下默认的字体。 Helvetica、Helvetica Neue，被广泛使用。 San Francisco，与苹方一样，mac os最新的西文字体。 font-family设置原则 西文优先：西文字体中大多不包含中文，西文优先，中文紧随其后，这样就不会影响到中文字体的选择。 从新到旧：优先体验最好的字体，向下兼容。 兼容多种操作系统：考虑windows, mac os, android, linux等系统。 补充字体族：最后根据衬线serif或无衬线sans-serif来补充字体族，当所有设置的字体都找不到时，让操作系统有选择字体的方向。 font-family推荐 font-family: \"Helvetica Neue\", Helvetica, \"PingFang SC\", Tahoma, \"Hiragino Sans GB\", \"Heiti SC\", Arial, \"Microsoft YaHei\", \"WenQuanYi Micro Hei\", sans-serif; var gitalk = new Gitalk({ clientID: \"c17498a9a9fa6e17b36a\", clientSecret: \"556df0480f8f48e142432f50273ea149cf206c07\", repo: \"FE-learning\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "},"doc/原生js创建ajax请求的步骤.html":{"url":"doc/原生js创建ajax请求的步骤.html","title":"原生js创建ajax请求的步骤","keywords":"","body":"创建 XMLHttpRequest 对象 // 兼容写法 if (window.XMLHttpRequest) { // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); } else { // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); } 设置请求的类型，URL以及是否异步(async) xmlhttp.open(\"GET\", \"/article/page\", true); xmlhttp.open(\"POST\", \"/article/add\", true); 备注： （1）当请求类型为GET时，传递的参数可直接放在URL的查询字符串中；POST请求的参数需要传入xmlhttp.send方法 （2）推荐设置async为true，使用异步的方式进行处理，需要通过onreadystatechange监听请求状态；如果async为false，则请求是同步的，就不需要监听请求状态了，直接在xmlhttp.send方法后写处理代码就可以了，但是同步请求是会阻塞的，此时浏览器看起来就像卡死了一样，没特殊情况千万别用同步请求。 设置请求头 xmlhttp.setRequestHeader(HTTP 头名称，HTTP请求头值)，举个示例： xmlhttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); 监听请求状态 xmlhttp.onreadystatechange= function(){ if (xmlhttp.readyState == 4 && xmlhttp.status == 200) { // 请求成功，进行业务处理 // ...... } } 备注： readyState有五种状态： 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 我们主要关注状态4 发送请求 xmlhttp.send()，该方法可以携带POST请求的参数，参数写法也是查询字符串格式，示例： xmlhttp.send('username=Tusi&password=999999') var gitalk = new Gitalk({ clientID: \"c17498a9a9fa6e17b36a\", clientSecret: \"556df0480f8f48e142432f50273ea149cf206c07\", repo: \"FE-learning\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "},"doc/ajax设置超时及监听事件.html":{"url":"doc/ajax设置超时及监听事件.html","title":"ajax设置超时及监听超时事件","keywords":"","body":"设置超时时间 xhr.timeout = 2000; // 超时时间，单位是毫秒 监听超时 xhr.ontimeout = function (e) { // XMLHttpRequest超时，做超时的提示或其他处理。 }; var gitalk = new Gitalk({ clientID: \"c17498a9a9fa6e17b36a\", clientSecret: \"556df0480f8f48e142432f50273ea149cf206c07\", repo: \"FE-learning\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "},"doc/ajax获取文件上传进度.html":{"url":"doc/ajax获取文件上传进度.html","title":"ajax获取文件上传进度","keywords":"","body":"示例代码 直接上代码： // 首先监听input框的变动，选中一个新的文件会触发change事件 document.querySelector(\"#file\").addEventListener(\"change\", function () { // 取得文件对象 var file = document.querySelector(\"#file\").files[0]; // 使用FormData保存文件数据 var formdata = new FormData(); formdata.append(\"file\", file); var xhr = new XMLHttpRequest(); xhr.open(\"post\", \"/upload\"); xhr.onreadystatechange = function () { if (xhr.readyState == 4 && xhr.status == 200) { // 上传完成 } } // 获取上传的进度 xhr.upload.onprogress = function (event) { if (event.lengthComputable) { // 计算出百分比 var percent = event.loaded / event.total * 100; // 修改进度条的宽度 document.querySelector(\"#progress\").style.width = percent + \"%\"; } } // 由于是post方式，文件数据formdata通过send方法进行传递 xhr.send(formdata); }); var gitalk = new Gitalk({ clientID: \"c17498a9a9fa6e17b36a\", clientSecret: \"556df0480f8f48e142432f50273ea149cf206c07\", repo: \"FE-learning\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "},"doc/vue项目中引入iconfont.html":{"url":"doc/vue项目中引入iconfont.html","title":"vue项目中引入iconfont","keywords":"","body":"背景 对于前端而言，图标的发展可谓日新月异。从img标签，到雪碧图，再到字体图标，svg，甚至svg也有了类似于雪碧图的方案svg-sprite-loader。雪碧图没有什么好讲的了，只是简单地利用了background-position来做图标定位。今天咱们先聊聊怎么使用字体图标和svg图标。其实字体图标也不陌生了，bootstrap，font-awesome，element-ui等UI库都基本标配了字体图标。 简单说下原理 unicode预留了E000-F8FF范围作为私有保留区域，这个区间的unicode码非常适合做字体图标，前端根据unicode码就能显示对应的图标。 vue项目引入iconfont 1. 在iconfont新建项目 注：这里修正一下，前缀应该是test-icon-。 2. 添加图标至项目 3. 使用iconfont Unicode方式（不推荐） 在线使用 index.scss中引入在线字体 @font-face { font-family: 'iconfont'; /* project id 1254715 */ src: url('//at.alicdn.com/t/font_1254715_s1khj1whikd.eot'); src: url('//at.alicdn.com/t/font_1254715_s1khj1whikd.eot?#iefix') format('embedded-opentype'), url('//at.alicdn.com/t/font_1254715_s1khj1whikd.woff2') format('woff2'), url('//at.alicdn.com/t/font_1254715_s1khj1whikd.woff') format('woff'), url('//at.alicdn.com/t/font_1254715_s1khj1whikd.ttf') format('truetype'), url('//at.alicdn.com/t/font_1254715_s1khj1whikd.svg#iconfont') format('svg'); } 页面中使用 使用时很不友好，使用的是unicode码表示，使用图标还必须去iconfont项目去查询下unicode码。 &#xe7ee; &#xe7ed; &#xe7ec; &#xe7eb; 效果图如下： 本地使用 有时候网络不是那么给力的，或者是内网环境，那么就不要考虑用在线引用的方式了。 本地使用需要先将字体库下载并放到项目中。 在全局样式文件中定义如下代码 @font-face { font-family: \"iconfont\"; src: url('../fonts/iconfont.eot'); /* IE9*/ src: url('../fonts/iconfont.eot#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('../fonts/iconfont.woff') format('woff'), /* chrome, firefox */ url('../fonts/iconfont.woff2') format('woff2'), /* chrome, firefox */ url('../fonts/iconfont.ttf') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url('../assets/fonts/iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */ } .iconfont { font-family: \"iconfont\" !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } 使用方式 与在线引用方式是一样的，都是使用unicode码去展示图标。 &#xe7ee; 总结 兼容性最好，支持ie6+，及所有现代浏览器。 支持按字体的方式去动态调整图标大小，颜色等等。 但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。 Font class方式（较友好） 一种更友好的封装，类似于font-awesome，我们只要使用class，就可以调用图标了。其原理就是利用before伪元素来显示图标。 在线使用 超级简单，只要在线生成代码，引用在线的css文件即可使用。 在index.html中引用它。 项目中就可以使用字体图标了。 本地使用 与unicode方式类似，下载代码到本地。因为我是用scss管理样式的，需要在下载的代码中提取出关键部分。除了引用字体库，还要将其中的iconfont.css中定义的before伪元素全部复制到自己的scss文件中。 @font-face { font-family: \"iconfont\"; src: url('../fonts/iconfont.eot'); /* IE9*/ src: url('../fonts/iconfont.eot#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('../fonts/iconfont.woff') format('woff'), /* chrome, firefox */ url('../fonts/iconfont.woff2') format('woff2'), /* chrome, firefox */ url('../fonts/iconfont.ttf') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url('../assets/fonts/iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */ } .iconfont { font-family: \"iconfont\" !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } // 列了一部分举例 .cl-icon-user:before { content: \"\\e64b\"; } .cl-icon-video:before { content: \"\\e66b\"; } .cl-icon-pause:before { content: \"\\e7bd\"; } .cl-icon-orgnazation:before { content: \"\\e61b\"; } 总结 兼容性良好，支持ie8+，及所有现代浏览器。 相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。 因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。 不过因为本质上还是使用的字体，所以多色图标还是不支持的。 建议 由于加了新的图标需要重新在iconfont.cn重新生成代码，所以这种方式也不算很方便，但是相对于unicode还是高级不少。根据我的经验，建议在调试时，不要每次图标更新，就下载到本地更换。应该先使用在线使用的方式，调试完毕确认无误后，再下载到本地使用，这样对于效率提升有很大帮助。 symbol方式（支持多色图标） svg的symbol提供了类似于雪碧图的功能，让svg的使用变得更简单，也可以满足做图标系统的需求。可以参考张大大博客了解更多关于svg symbol的知识。 在线使用 首先在iconfont项目中选择symbol方式，并在线生成js代码 然后在index.html中引入这个js文件 这个js的作用是在文档中生成svg symbol 最后就可以在页面中通过use标签使用svg图标了。xlink:href的值设置为对应的symbol的id即可。 效果如下： 多色图标还是酷！ 本地使用 本地使用也是一样的道理，主要是依赖这个在线生成的js文件，将在线js文件的链接在浏览器空标签中打开，就可以得到其内容，然后复制内容，自己命名一个js文件，并把它放在本地项目静态资源目录下，引用即可。 图标自动管理（必看） 即使使用了symbol方式，当设计小姐姐新增图标时，我们还是无法避免重新生成图标代码。那么有没有更优雅的解决方案呢？答案是有的。svg-sprite-loader + require.context。 svg-sprite-loader网上已经有太多文章了。 关于require.context，我倒是有一点自己的理解。请查看一张图带你了解webpack的require.context。 总结 支持多色图标了，不再受单色限制。 支持丰富的css属性进行定制。 兼容性较差，支持 ie9+,及现代浏览器。 浏览器渲染svg的性能一般，还不如png。 var gitalk = new Gitalk({ clientID: \"c17498a9a9fa6e17b36a\", clientSecret: \"556df0480f8f48e142432f50273ea149cf206c07\", repo: \"FE-learning\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "},"doc/vue作用域插槽，你真的懂了吗.html":{"url":"doc/vue作用域插槽，你真的懂了吗.html","title":"vue作用域插槽，你真的懂了吗","keywords":"","body":"前言 在网上搜了很多关于作用域插槽的解释，感觉没有写得很具体的吧，我认为应该对组件化有很深的理解才会触及到这个问题吧，这里也分享下我自己对于slot-scope的一点理解。 slot大家看看文档都懂了，无非就是在子组件中挖个坑，坑里面放什么东西由父组件决定。 // 子组件 来啊，我这里挖了个坑 // 父组件 我在这放个span，乐意的话，放个组件都行 给slot传入普通文本 给slot传入了一个图像处理组件 具名插槽也很简单，比如有多个插槽，我作为父组件，肯定想区别子组件中的几个插槽，那就要用slot标签的name属性来标识了，而父组件要决定在什么插槽里面放什么内容，就要将name的值赋值给slot属性传递给对应的插槽。如果slot没有name属性，就是匿名插槽了，而父组件中不指定slot属性的内容，就会被丢到匿名插槽中。 // 子组件 这里放标题 这里放作者 这里放文章内容 // 父组件 vue作用域插槽，你真的懂了吗？ 好像有点懂了 王五 最难理解的是作用域插槽。看了文档说明的朋友可能还会有点晕，大概是说在作用域插槽内，父组件可以拿到子组件的数据。子组件可以在slot标签上绑定属性值，如： 而父组件通过slot-scope绑定的对象下拿到nickName的值。 这里大家应该都有疑问。这有什么用？我在子组件用$emit向父组件传递数据不就行了？ 关于作用域插槽的一点理解 我觉得要从组件之间的数据流向来思考作用域插槽的应用场景。 假设第一个场景，需要你写一个商品卡片组件，并通过循环去展示多个卡片，并且要求能响应每个卡片上的图片或者其他内容的点击事件而跳转到商品详情页，你会怎么写？ 我会使用如下的处理方式，首先将商品卡片写成一个组件Commodity.vue，而在CommodityList.vue中用一个v-for来处理商品卡片列表的展示。 Commodity组件通过$emit像父组件传递clickCommodity事件，并携带商品数据，父组件即可在onCommodityClick方法中得到数据，进行业务处理，这样便完成了一个基本的由子到父的数据传递。 如果再往上抽象一下呢？比如我有多个运营栏目，像淘宝首页有“有好货”，“爱逛街”这样两个栏目，每个栏目下都需要有一个商品卡片列表，那么商品卡片列表CommodityList.vue就要抽成组件了。而这个包含多个运营栏目的vue组件我假设它叫ColumnList.vue，在其中通过v-for调用了CommodityList组件。 注意：业务来了，我希望把点击商品卡片的业务放在ColumnList.vue中处理。你们想象一下要怎么做？一种土办法就是商品按钮点击时，Commodity组件$emit通知CommodityList.vue，而CommodityList接着把事件用$emit往上抛，那么ColumnList.vue就能处理这个点击事件了。这样做完全没有问题，但是显得子组件很不纯粹，跟业务都扯上关系了。 那么如何优雅地解决这个问题呢？这个时候，作用域插槽真正派上用场了。 通过作用域插槽将本应该由CommodityList处理的商品卡片点击业务onCommodityClick提升到ColumnList处理。 而CommodityList组件内部应该是改造成这样，slot接收来自父组件的商品卡片组件，这里面不涉及关于商品组件的业务，只关注其他业务和布局即可。最终就实现了组件和业务的剥离，这也是组件化的精髓所在吧。不知道有没有帮到您呢？ 这是我实现的效果，忽略样式吧，原理都懂了，做个漂亮的卡片有多难？ 总结一下，作用域插槽适合的场景是至少包含三级以上的组件层级，是一种优秀的组件化方案！ var gitalk = new Gitalk({ clientID: \"c17498a9a9fa6e17b36a\", clientSecret: \"556df0480f8f48e142432f50273ea149cf206c07\", repo: \"FE-learning\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "},"doc/从一道面试题简单谈谈发布订阅和观察者模式.html":{"url":"doc/从一道面试题简单谈谈发布订阅和观察者模式.html","title":"从一道面试题简单谈谈发布订阅和观察者模式","keywords":"","body":"今天的话题是javascript中常被提及的「发布订阅模式和观察者模式」，提到这，我不由得想起了一次面试。记得在去年的一次求职面试过程中，面试官问我，“你在项目中是怎么处理非父子组件之间的通信的？”。我答道，“有用到vuex，有的场景也会用EventEmitter2”。面试官继续问，“那你能手写代码，实现一个简单的EventEmitter吗？” 手写EventEmitter 我犹豫了一会儿，想到使用EventEmitter2时，主要是用emit发事件，用on监听事件，还有off销毁事件监听者，removeAllListeners销毁指定事件的所有监听者，还有once之类的方法。考虑到时间关系，我想着就先实现发事件，监听事件，移除监听者这几个功能。当时可能有点紧张，不过有惊无险，在面试官给了一点提示后，顺利地写出来了！现在把这部分代码也记下来。 class EventEmitter { constructor() { // 维护事件及监听者 this.listeners = {} } /** * 注册事件监听者 * @param {String} type 事件类型 * @param {Function} cb 回调函数 */ on(type, cb) { if (!this.listeners[type]) { this.listeners[type] = [] } this.listeners[type].push(cb) } /** * 发布事件 * @param {String} type 事件类型 * @param {...any} args 参数列表，把emit传递的参数赋给回调函数 */ emit(type, ...args) { if (this.listeners[type]) { this.listeners[type].forEach(cb => { cb(...args) }) } } /** * 移除某个事件的一个监听者 * @param {String} type 事件类型 * @param {Function} cb 回调函数 */ off(type, cb) { if (this.listeners[type]) { const targetIndex = this.listeners[type].findIndex(item => item === cb) if (targetIndex !== -1) { this.listeners[type].splice(targetIndex, 1) } if (this.listeners[type].length === 0) { delete this.listeners[type] } } } /** * 移除某个事件的所有监听者 * @param {String} type 事件类型 */ offAll(type) { if (this.listeners[type]) { delete this.listeners[type] } } } // 创建事件管理器实例 const ee = new EventEmitter() // 注册一个chifan事件监听者 ee.on('chifan', function() { console.log('吃饭了，我们走！') }) // 发布事件chifan ee.emit('chifan') // 也可以emit传递参数 ee.on('chifan', function(address, food) { console.log(`吃饭了，我们去${address}吃${food}！`) }) ee.emit('chifan', '三食堂', '铁板饭') // 此时会打印两条信息，因为前面注册了两个chifan事件的监听者 // 测试移除事件监听 const toBeRemovedListener = function() { console.log('我是一个可以被移除的监听者') } ee.on('testoff', toBeRemovedListener) ee.emit('testoff') ee.off('testoff', toBeRemovedListener) ee.emit('testoff') // 此时事件监听已经被移除，不会再有console.log打印出来了 // 测试移除chifan的所有事件监听 ee.offAll('chifan') console.log(ee) // 此时可以看到ee.listeners已经变成空对象了，再emit发送chifan事件也不会有反应了 有了这个自己写的简单版本的EventEmitter，我们就不用依赖第三方库啦。对了，vue也可以帮我们做这样的事情。 const ee = new Vue(); ee.$on('chifan', function(address, food) { console.log(`吃饭了，我们去${address}吃${food}！`) }) ee.$emit('chifan', '三食堂', '铁板饭') 所以我们可以单独new一个Vue的实例，作为事件管理器导出给外部使用。想测试的朋友可以直接打开vue官网，在控制台试试，也可以在自己的vue项目中实践下哦。 发布订阅模式 其实仔细看看，EventEmitter就是一个典型的发布订阅模式，实现了事件调度中心。发布订阅模式中，包含发布者，事件调度中心，订阅者三个角色。我们刚刚实现的EventEmitter的一个实例ee就是一个事件调度中心，发布者和订阅者是松散耦合的，互不关心对方是否存在，他们关注的是事件本身。发布者借用事件调度中心提供的emit方法发布事件，而订阅者则通过on进行订阅。 如果还不是很清楚的话，我们把代码换下单词，是不是变得容易理解一点呢？ class PubSub { constructor() { // 维护事件及订阅行为 this.events = {} } /** * 注册事件订阅行为 * @param {String} type 事件类型 * @param {Function} cb 回调函数 */ subscribe(type, cb) { if (!this.events[type]) { this.events[type] = [] } this.events[type].push(cb) } /** * 发布事件 * @param {String} type 事件类型 * @param {...any} args 参数列表 */ publish(type, ...args) { if (this.events[type]) { this.events[type].forEach(cb => { cb(...args) }) } } /** * 移除某个事件的一个订阅行为 * @param {String} type 事件类型 * @param {Function} cb 回调函数 */ unsubscribe(type, cb) { if (this.events[type]) { const targetIndex = this.events[type].findIndex(item => item === cb) if (targetIndex !== -1) { this.events[type].splice(targetIndex, 1) } if (this.events[type].length === 0) { delete this.events[type] } } } /** * 移除某个事件的所有订阅行为 * @param {String} type 事件类型 */ unsubscribeAll(type) { if (this.events[type]) { delete this.events[type] } } } 画图分析 最后，我们画个图加深下理解： 特点 发布订阅模式中，对于发布者Publisher和订阅者Subscriber没有特殊的约束，他们好似是匿名活动，借助事件调度中心提供的接口发布和订阅事件，互不了解对方是谁。 松散耦合，灵活度高，常用作事件总线 易理解，可类比于DOM事件中的dispatchEvent和addEventListener。 缺点 当事件类型越来越多时，难以维护，需要考虑事件命名的规范，也要防范数据流混乱。 观察者模式 观察者模式与发布订阅模式相比，耦合度更高，通常用来实现一些响应式的效果。在观察者模式中，只有两个主体，分别是目标对象Subject，观察者Observer。 观察者需Observer要实现update方法，供目标对象调用。update方法中可以执行自定义的业务代码。 目标对象Subject也通常被叫做被观察者或主题，它的职能很单一，可以理解为，它只管理一种事件。Subject需要维护自身的观察者数组observerList，当自身发生变化时，通过调用自身的notify方法，依次通知每一个观察者执行update方法。 按照这种定义，我们可以实现一个简单版本的观察者模式。 // 观察者 class Observer { /** * 构造器 * @param {Function} cb 回调函数，收到目标对象通知时执行 */ constructor(cb){ if (typeof cb === 'function') { this.cb = cb } else { throw new Error('Observer构造器必须传入函数类型！') } } /** * 被目标对象通知时执行 */ update() { this.cb() } } // 目标对象 class Subject { constructor() { // 维护观察者列表 this.observerList = [] } /** * 添加一个观察者 * @param {Observer} observer Observer实例 */ addObserver(observer) { this.observerList.push(observer) } /** * 通知所有的观察者 */ notify() { this.observerList.forEach(observer => { observer.update() }) } } const observerCallback = function() { console.log('我被通知了') } const observer = new Observer(observerCallback) const subject = new Subject(); subject.addObserver(observer); subject.notify(); 画图分析 最后也整张图理解下观察者模式： 特点 角色很明确，没有事件调度中心作为中间者，目标对象Subject和观察者Observer都要实现约定的成员方法。 双方联系更紧密，目标对象的主动性很强，自己收集和维护观察者，并在状态变化时主动通知观察者更新。 缺点 我还没体会到，这里不做评价 结语 关于这个话题，网上文章挺多的，观点上可能也有诸多分歧。重复造轮子，纯属帮助自己加深理解。 本人水平有限，以上仅是个人观点，如有错误之处，还请斧正！如果能帮到您理解发布订阅模式和观察者模式，非常荣幸！ 如果有兴趣看看我这糟糕的代码，请点击github，祝大家生活愉快！ 首发链接 var gitalk = new Gitalk({ clientID: \"c17498a9a9fa6e17b36a\", clientSecret: \"556df0480f8f48e142432f50273ea149cf206c07\", repo: \"FE-learning\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "},"doc/前端API层架构，也许你做得还不够.html":{"url":"doc/前端API层架构，也许你做得还不够.html","title":"前端API层架构，也许你做得还不够","keywords":"","body":"上午好，今天为大家分享下个人对于前端API层架构的一点经验和看法。架构设计是一条永远走不完的路，没有最好，只有更好。这个道理适用于软件设计的各个场景，前端API层的设计也不例外，如果您觉得在调用接口时还存在诸多槽点，那就说明您的接口层架构还待优化。今天我以vue + axios为例，为大家梳理下我的一些经历和设想。 石器时代，痛苦 直接调用axios，真的痛苦，每个调用的地方都要进行响应状态的判断，冗余代码超级多。 import axios from \"axios\" axios.get('/usercenter/user/page?pageNo=1&pageSize=10').then(res => { const data = res.data // 判断请求状态，success字段为true代表成功，视前后端约束而定 if (data.success) { // 结果成功后的业务代码 } else { // 结果失败后的业务代码 } }) 看起来确实很难受，每调用一次接口，就有这么多重复的工作！ 青铜器时代，中规中矩 为了解决直接调用axios的痛点，我们一般会利用Promise对axios二次封装，对接口响应状态进行集中判断，对外暴露get, post, put, delete等http方法。 axios二次封装 import axios from \"axios\" import router from \"@/router\" import { BASE_URL } from \"@/router/base-url\" import { errorMsg } from \"@/utils/msg\"; import { stringify } from \"@/utils/helper\"; // 创建axios实例 const v3api = axios.create({ baseURL: process.env.BASE_API, timeout: 10000 }); // axios实例默认配置 v3api.defaults.headers.common['Content-Type'] = 'application/x-www-form-urlencoded'; v3api.defaults.transformRequest = data => { return stringify(data) } // 返回状态拦截，进行状态的集中判断 v3api.interceptors.response.use( response => { const res = response.data; if (res.success) { return Promise.resolve(res) } else { // 内部错误码处理 if (res.code === 1401) { errorMsg(res.message || '登录已过期，请重新登录！') router.replace({ path: `${BASE_URL}/login` }) } else { // 默认的错误提示 errorMsg(res.message || '网络异常，请稍后重试！') } return Promise.reject(res); } }, error => { if (/timeout\\sof\\s\\d+ms\\sexceeded/.test(error.message)) { // 超时 errorMsg('网络出了点问题，请稍后重试！') } if (error.response) { // http状态码判断 switch (error.response.status) { // http status handler case 404: errorMsg('请求的资源不存在！') break case 500: errorMsg('内部错误，请稍后重试！') break case 503: errorMsg('服务器正在维护，请稍等！') break } } return Promise.reject(error.response) } ) // 处理get请求 const get = (url, params, config = {}) => v3api.get(url, { ...config, params }) // 处理delete请求，为了防止和关键词delete冲突，方法名定义为deletes const deletes = (url, params, config = {}) => v3api.delete(url, { ...config, params }) // 处理post请求 const post = (url, params, config = {}) => v3api.post(url, params, config) // 处理put请求 const put = (url, params, config = {}) => v3api.put(url, params, config) export default { get, deletes, post, put } 调用者不再判断请求状态 import api from \"@/api\"; methods: { getUserPageData() { api.get('/usercenter/user/page?pageNo=1&pageSize=10').then(res => { // 状态已经集中判断了，这里直接写成功的逻辑 // 业务代码...... const result = res.result; }).catch(res => { // 失败的情况写在catch中 }) } } async/await改造 使用语义化的异步函数 methods: { async getUserPageData() { try { const res = await api.get('/usercenter/user/page?pageNo=1&pageSize=10') // 业务代码...... const { result } = res; } catch(error) { // 失败的情况写在catch中 } } } 存在的问题 语义化程度有限，调用接口还是需要查询接口url 前端api层难以维护，如后端接口发生改动，前端每处都需要大改。 如果UI组件的数据模型与后端接口要求的数据结构存在差异，每处调用接口前都需要进行数据处理，抹平差异，比如[1,2,3]转1,2,3这种（当然，这只是最简单的一个例子）。这样如果数据处理不慎，调用者出错几率太高！ 难以满足特殊化场景，举个例子，一个查询的场景，后端要求，如果输入了搜索关键词keyword，必须调用/user/search接口，如果没有输入关键词，只能调用/user/page接口。如果每个调用者都要判断是不是输入了关键词，再决定调用哪个接口，你觉得出错几率有多大，用起来烦不烦？ 产品说，这些场景需要优化，默认按创建时间降序排序。我擦，又一个个改一遍？ ...... 那么怎么解决这些问题呢？请耐心接着看...... 铁器时代，it's cool 我想到的方案是在底层封装和调用者之间再增加一层API适配层（适配层，取量身定制之意），在适配层做统一处理，包括参数处理，请求头处理，特殊化处理等，提炼出更语义化的方法，让调用者“傻瓜式”调用，不再为了查找接口url和处理数据结构这些重复的工作而烦恼，把ViewModel层绑定的数据模型直接丢给适配层统一处理。 对齐微服务架构 首先，为了对齐后端微服务架构，在前端将API调用分为三个模块。 ├─api index.js axios底层封装 ├─base 负责调用基础服务,basecenter ├─iot 负责调用物联网服务,iotcenter └─user 负责调用用户相关服务,usercenter 每个模块下都定义了统一的微服务命名空间，例如/src/api/user/index.js： export const namespace = 'usercenter'; 特性模块 每个功能特性都有独立的js模块，以角色管理相关接口为例，模块是/src/api/user/role.js import api from '../index' import { paramsFilter } from \"@/utils/helper\"; import { namespace } from \"./index\" const feature = 'role' // 添加角色 export const addRole = params => api.post(`/${namespace}/${feature}/add`, paramsFilter(params)); // 删除角色 export const deleteRole = id => api.deletes(`/${namespace}/${feature}/delete`, { id }); // 更新角色 export const updateRole = params => api.put(`/${namespace}/${feature}/update`, paramsFilter(params)); // 条件查询角色 export const findRoles = params => api.get(`/${namespace}/${feature}/find`, paramsFilter(params)); // 查询所有角色，不传参调用find接口代表查询所有角色 export const getAllRoles = () => findRoles(); // 获取角色详情 export const getRoleDetail = id => api.get(`/${namespace}/${feature}/detail`, { id }); // 分页查询角色 export const getRolePage = params => api.get(`/${namespace}/${feature}/page`, paramsFilter(params)); // 搜索角色 export const searchRole = params => params.keyword ? api.get(`/${namespace}/${feature}/search`, paramsFilter(params)) : getRolePage(params); 每一条接口都根据RESTful风格，调用增（api.post）删（api.deletes）改（api.put）查（api.get）的底层方法，对外输出语义化方法。 调用的url由三部分组成，格式：/微服务命名空间/特性命名空间/方法 接口适配层函数命名规范： 新增：addXXX 删除：deleteXXX 更新：updateXXX 根据ID查询记录：getXXXDetail 条件查询一条记录：findOneXXX 条件查询：findXXXs 查询所有记录：getAllXXXs 分页查询：getXXXPage 搜索：searchXXX 其余个性化接口根据语义进行命名 解决问题 语义化程度更高，配合vscode的代码提示功能，用起来不要太爽！ 迅速响应接口改动，适配层统一处理 集中进行数据处理（对于公用的数据处理，我们用paramsFilter解决，对于特殊的情况，再另行处理），调用者安心做业务即可 满足特殊场景，佛系应对后端和产品朋友 针对上节提到的关键字查询场景，我们在适配层通过在入参中判断是否有keyword字段，决定调用search还是page接口。对外我们只需暴露searchRole方法，调用者只需要调用searchRole方法即可，无需做其他考虑。 export const searchRole = params => params.keyword ? api.get(`/${namespace}/${feature}/search`, paramsFilter(params)) : getRolePage(params); 针对产品突然加的排序需求，我们可以在适配层去做默认入参的处理。 首先，我们新建一个专门管理默认参数的js，如src/api/default-options.js // 默认按创建时间降序的参数对象 export const SORT_BY_CREATETIME_OPTIONS = { sortField: 'createTime', // desc代表降序，asc是升序 sortType: 'desc' } 接着，我们在接口适配层做集中化处理 import api from '../index' import { SORT_BY_CREATETIME_OPTIONS } from \"../default-options\" import { paramsFilter } from \"@/utils/helper\"; import { namespace } from \"./index\" const feature = 'role' export const getRolePage = params => api.get(`/${namespace}/${feature}/page`, paramsFilter({ ...SORT_BY_CREATETIME_OPTIONS, ...params })); SORT_BY_CREATETIME_OPTIONS放在前面，是为了满足如果出现其他排序需求，调用者传入的排序字段能覆盖掉默认参数。 mock先行 一个完善的API层设计，肯定是离不开mock的。在后端提供接口之前，前端必须通过模拟数据并行开发，否则进度无法保证。那么如何设计一个跟真实接口契合度高的mock系统呢？我这里简单做下分享。 首先，创建mock专用的axios实例 我们在src目录下新建mock目录，并在src/mock/index.js简单封装一个axios实例 // 仅限模拟数据使用 import axios from \"axios\" const mock = axios.create({ baseURL: '' }); // 返回状态拦截 mock.interceptors.response.use( response => { return Promise.resolve(response.data) }, error => { return Promise.reject(error.response) } ) export default mock mock同样也要分模块，以usercenter微服务下的角色管理mock接口为例 ├─mock index.js mock底层axios封装 ├─user 负责调用基础服务,usercenter ├─role ├─index.js 我们在src/mock/user/role/index.js中简单模拟一个获取所有角色的接口getAllRoles import mock from \"@/mock\"; export const getAllRoles = () => mock.get('/static/mock/user/role/getAllRoles.json') 可以看到，我们是在mock接口中获取了static/mock目录下的json数据。因此我们需要根据接口文档或者约定好的数据结构准备好getAllRoles.json数据 { \"success\": true, \"result\": { \"pageNo\": 1, \"pageSize\": 10, \"total\": 2, \"list\": [ { \"id\": 1, \"createTime\": \"2019-11-19 12:53:05\", \"updateTime\": \"2019-12-03 09:53:41\", \"name\": \"管理员\", \"code\": \"管理员\", \"description\": \"一个拥有部分权限的管理员角色\", \"sort\": 1, \"menuIds\": \"789,2,55,983,54\", \"menuNames\": \"数据字典, 后台, 账户信息, 修改密码, 账户中心\" }, { \"id\": 2, \"createTime\": \"2019-11-27 17:18:54\", \"updateTime\": \"2019-12-01 19:14:30\", \"name\": \"前台测试\", \"code\": \"前台测试\", \"description\": \"一个拥有部分权限的前台测试角色\", \"sort\": 2, \"menuIds\": \"15,4,1\", \"menuNames\": \"油耗统计, 车联网, 物联网监管系统\" } ] }, \"message\": \"请求成功\", \"code\": 0 } 我们来看看mock是怎么做的 先看下真实接口的调用方式 import { getAllRoles } from \"@/api/user/role\"; created() { this.getAllRolesData() }, methods: { async getAllRolesData() { const res = await getAllRoles() console.log(res) } } 那么mock时怎么做呢？非常简单，只要将mock中提供的方法替代掉api提供的方法即可。 // import { getAllRoles } from \"@/api/user/role\"; import { getAllRoles } from \"@/mock/user/role\"; 可以看到，这种mock方式与调用真实接口的契合度还是挺高的，正式调试接口时，只需将注释的代码调整即可，过渡非常平滑！ 注意，在生产环境下，为了防止打包时将static/mock目录下的内容copy到dist目录下，我们需要配置下CopyWebpackPlugin，以vue-cli@2为例，我们修改webpack.base.conf.js即可。 const devMode = process.env.NODE_ENV === 'development'; new CopyWebpackPlugin([ { from: path.resolve(__dirname, '../static'), to: devMode ? config.dev.assetsSubDirectory : config.build.assetsSubDirectory, ignore: devMode ? '' : 'mock/**/*' } ]) 蒸汽时代，真香 下一步的设想，使用类型安全的typescript，让前端API层真正做到面向接口文档编程，规范入参，出参，可选参数，等等，提高可维护性，在编码阶段就大大降低出错几率。虽然还在重构阶段，但是我想说，重拾typescript是真香，突然怀念使用Angular的那两年了，期待vue3.0能将typescript结合得更加完美...... 电气时代，更多畅想 未来还有无限可能，面对日渐复杂和多样化的业务场景，我们会提炼出更好的架构和设计模式。目前有一个不成熟的设想，是否能在接口设计上做到更规范化，后端输出接口文档的同时，提炼出API json之类的数据结构？前端拿到API json，通过nodejs文件编程的能力，自动化生成前端接口层代码，解放双手。 结语 当然，以上只是我的一点点经验和设想，是在我能力范围内能想到的东西，希望能帮助到一些有需要的同学。如果大佬们有更好的经验，可以指点一二。 首发链接 往期精彩： 用初中数学知识撸一个canvas环形进度条 var gitalk = new Gitalk({ clientID: \"c17498a9a9fa6e17b36a\", clientSecret: \"556df0480f8f48e142432f50273ea149cf206c07\", repo: \"FE-learning\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "},"doc/用初中数学知识撸一个canvas环形进度条.html":{"url":"doc/用初中数学知识撸一个canvas环形进度条.html","title":"用初中数学知识撸一个canvas环形进度条","keywords":"","body":"周末好，今天给大家带来一款接地气的环形进度条组件vue-awesome-progress。近日被设计小姐姐要求实现这么一个环形进度条效果，大体由四部分组成，分别是底色圆环，进度弧，环内文字，进度圆点。设计稿截图如下： 我的第一反应还是找现成的组件，市面上很多组件都实现了前3点，独独没找到能画进度圆点的组件，不然稍加定制也能复用。既然没有现成的组件，只有自己用vue + canvas撸一个了。 效果图 先放个效果图，然后再说下具体实现过程，各位看官且听我慢慢道来。 安装与使用 源码地址，欢迎star和提issue。 安装 npm install --save vue-awesome-progress 使用 全局注册 import Vue from 'vue' import VueAwesomeProgress from \"vue-awesome-progress\" Vue.use(VueAwesomeProgress) 局部使用 import VueAwesomeProgress from \"vue-awesome-progress\" export default { components: { VueAwesomeProgress }, // 其他代码 } webpack配置 由于当前版本发布时，未进行babel编译，因此使用时需要自行将vue-awesome-progress纳入babel-loader的解析范围。示例如下： // resolve函数是连接路径的，方法体是path.join(__dirname, \"..\", dir) { test: /\\.js$/, loader: \"babel-loader\", include: [ resolve(\"src\"), resolve(\"node_modules/vue-awesome-progress\") ] } 静态展示 任何事都不是一蹴而就的，我们首先来实现一个静态的效果，然后再实现动画效果，甚至是复杂的控制逻辑。 确定画布大小 第一步是确定画布大小。从设计稿我们可以直观地看到，整个环形进度条的最外围是由进度圆点确定的，而进度圆点的圆心在圆环圆周上。 因此我们得出伪代码如下： // canvasSize: canvas宽度/高度 // outerRadius: 外围半径 // pointRadius: 圆点半径 // pointRadius: 圆环半径 canvasSize = 2 * outerRadius = 2 * (pointRadius + circleRadius) 据此我们可以定义如下组件属性： props: { circleRadius: { type: Number, default: 40 }, pointRadius: { type: Number, default: 6 } }, computed: { // 外围半径 outerRadius() { return this.circleRadius + this.pointRadius }, // canvas宽/高 canvasSize() { return 2 * this.outerRadius + 'px' } } 那么canvas大小也可以先进行绑定了 获取绘图上下文 getContext('2d')方法返回一个用于在canvas上绘图的环境，支持一系列2d绘图API。 mounted() { // 在$nextTick初始化画布，不然dom还未渲染好 this.$nextTick(() => { this.initCanvas() }) }, methods: { initCanvas() { var canvas = this.$refs.canvasDemo; var ctx = canvas.getContext('2d'); } } 画底色圆环 完成了上述步骤后，我们就可以着手画各个元素了。我们先画圆环，这时我们还要定义两个属性，分别是圆环线宽circleWidth和圆环颜色circleColor。 circleWidth: { type: Number, default: 2 }, circleColor: { type: String, default: '#3B77E3' } canvas提供的画圆弧的方法是ctx.arc()，需要提供圆心坐标，半径，起止弧度，是否逆时针等参数。 ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise); 我们知道，Web网页中的坐标系是这样的，从绝对定位的设置上其实就能看出来（top，left设置正负值会发生什么变化），而且原点(0, 0)是在盒子（比如说canvas）的左上角哦。 对于角度而言，0°是x轴正向，默认是顺时针方向旋转。 圆环的圆心就是canvas的中心，所以x, y 取outerRadius的值就可以了。 ctx.strokeStyle = this.circleColor; ctx.lineWidth = this.circleWidth; ctx.beginPath(); ctx.arc(this.outerRadius, this.outerRadius, this.circleRadius, 0, this.deg2Arc(360)); ctx.stroke(); 注意arc传的是弧度参数，而不是我们常理解的360°这种概念，因此我们需要将我们理解的360°转为弧度。 // deg转弧度 deg2Arc(deg) { return deg / 180 * Math.PI } 画文字 调用fillText绘制文字，利用canvas.clientWidth / 2和canvas.clientWidth / 2取得中点坐标，结合控制文字对齐的两个属性textAlign和textBaseline，我们可以将文字绘制在画布中央。文字的值由label属性接收，字体大小由fontSize属性接收，颜色则取的fontColor。 if (this.label) { ctx.font = `${this.fontSize}px Arial,\"Microsoft YaHei\"` ctx.fillStyle = this.fontColor; ctx.textAlign = 'center' ctx.textBaseline = 'middle' ctx.fillText(this.label, canvas.clientWidth / 2, canvas.clientWidth / 2); } 画进度弧 支持普通颜色和渐变色，withGradient默认为true，代表使用渐变色绘制进度弧，渐变方向我默认给的从上到下。如果希望使用普通颜色，withGradient传false即可，并可以通过lineColor自定义颜色。 if (this.withGradient) { this.gradient = ctx.createLinearGradient(this.circleRadius, 0, this.circleRadius, this.circleRadius * 2); this.lineColorStops.forEach(item => { this.gradient.addColorStop(item.percent, item.color); }); } 其中lineColorStops是渐变色的颜色偏移断点，由父组件传入，可传入任意个颜色断点，格式如下： colorStops2: [ { percent: 0, color: '#FF9933' }, { percent: 1, color: '#FF4949' } ] 画一条从上到下的进度弧，即270°到90° ctx.strokeStyle = this.withGradient ? this.gradient : this.lineColor; ctx.lineWidth = this.lineWidth; ctx.beginPath(); ctx.arc(this.outerRadius, this.outerRadius, this.circleRadius, this.deg2Arc(270), this.deg2Arc(90)); ctx.stroke(); 其中lineWidth是弧线的宽度，由父组件传入 lineWidth: { type: Number, default: 8 } 画进度圆点 最后我们需要把进度圆点补上，我们先写死一个角度90°，显而易见，圆点坐标为(this.outerRadius, this.outerRadius + this.circleRadius) 画圆点的代码如下： ctx.fillStyle = this.pointColor; ctx.beginPath(); ctx.arc(this.outerRadius, this.outerRadius + this.circleRadius, this.pointRadius, 0, this.deg2Arc(360)); ctx.fill(); 其中pointRadius是圆点的半径，由父组件传入： pointRadius: { type: Number, default: 6 } 角度自定义 当然，进度条的角度是灵活定义的，包括开始角度，结束角度，都应该由调用者随意给出。因此我们再定义一个属性angleRange，用于接收起止角度。 angleRange: { type: Array, default: function() { return [270, 90] } } 有了这个属性，我们就可以随意地画进度弧和圆点了，哈哈哈哈。 老哥，这种圆点坐标怎么求？ 噗......看来高兴过早了，最重要的是根据不同角度求得圆点的圆心坐标，这让我顿时犯了难。 经过冷静思考，我脑子里闪过了一个利用正余弦公式求坐标的思路，但前提是坐标系原点如果在圆环外接矩形的左上角才好算。仔细想想，冇问题啦，我先给坐标系平移一下，最后求出来结果，再补个平移差值不就行了嘛。 画图工具不是很熟练，这里图没画好，线歪了，请忽略细节。 好的，我们先给坐标系向右下方平移pointRadius，最后求得结果再加上pointRadius就好了。伪代码如下： // realx：真实的x坐标 // realy：真实的y坐标 // resultx：平移后求取的x坐标 // resultx：平移后求取的y坐标 // pointRadius 圆点半径 realx = resultx + pointRadius realy = resulty + pointRadius 求解坐标的思路大概如下，分四个范围判断，得出求解公式，应该还可以化简，不过我数学太菜了，先这样吧。 getPositionsByDeg(deg) { let x = 0; let y = 0; if (deg >= 0 && deg 90 && deg 180 && deg 最后再补上偏移值即可。 const pointPosition = this.getPositionsByDeg(nextDeg); ctx.arc(pointPosition.x + this.pointRadius, pointPosition.y + this.pointRadius, this.pointRadius, 0, this.deg2Arc(360)); 这样，一个基本的canvas环形进度条就成型了。 动画展示 静态的东西逼格自然是不够的，因此我们需要再搞点动画效果装装逼。 基础动画 我们先简单实现一个线性的动画效果。基本思路是把开始角度和结束角度的差值分为N段，利用window.requestAnimationFrame依次执行动画。 比如从30°到90°，我给它分为6段，每次画10°。要注意canvas画这种动画过程一般是要重复地清空画布并重绘的，所以第一次我画的弧线范围就是30°~40°，第二次我画的弧线范围就是30°~50°，以此类推...... 基本的代码结构如下，具体代码请参考vue-awesome-progress v1.1.0版本，如果顺手帮忙点个star也是极好的。 animateDrawArc(canvas, ctx, startDeg, endDeg, nextDeg, step) { window.requestAnimationFrame(() => { // 清空画布 ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight); // 求下一个目标角度 nextDeg = this.getTargetDeg(nextDeg || startDeg, endDeg, step); // 画圆环 // 画文字 // 画进度弧线 // 画进度圆点 if (nextDeg !== endDeg) { // 满足条件继续调用动画，否则结束动画 this.animateDrawArc(canvas, ctx, startDeg, endDeg, nextDeg, step) } } } 缓动效果 线性动画显得有点单调，可操作性不大，因此我考虑引入贝塞尔缓动函数easing，并且支持传入动画执行时间周期duration，增强了可定制性，使用体验更好。这里不列出实现代码了，请前往vue-awesome-progress查看。 // 省略部分... 可以看到，当传入不同的动画周期duration和缓动参数easing时，动画效果各异，完全取决于使用者自己。 其他效果 当然根据组件支持的属性，我们也可以定制出其他效果，比如不显示文字，不显示圆点，弧线线宽与圆环线宽一样，不使用渐变色，不需要动画，等等。我们后续也会考虑支持更多能力，比如控制进度，数字动态增长等！具体使用方法，请参考vue-awesome-progress。 更新日志 2019年11月10日更新 由于我从业务场景出发做了这个组件，没有考虑到大部分场景都是传百分比控制进度的，因此在v1.4.0版本做了如下修正： 废弃angle-range，改用percentage控制进度，同时提供start-deg属性控制起始角度； with-gradient改为use-gradient 通过show-text控制是否显示进度文字 支持通过format函数自定义显示文字的规则 结语 写完这个组件有让我感觉到，程序员最终不是输给了代码和技术的快速迭代，而是输给了自己的逻辑思维能力和数学功底。就vue-awesome-progress这个组件而言，根据这个思路，我们也能迅速开发出适用于React，Angular以及其他框架生态下的组件。工作三年有余，接触了不少框架和技术，经历了MVVM，Hybrid，小程序，跨平台，大前端，serverless的大火，也时常感慨“学不动了”，在这个快速演进的代码世界里常常感到失落。好在自己还没有丢掉分析问题的能力，而不仅仅是调用各种API和插件，这可能是程序员最宝贵的财富吧。前路坎坷，我辈当不忘初心，愿你出走半生，归来仍是少年！ 首发链接 var gitalk = new Gitalk({ clientID: \"c17498a9a9fa6e17b36a\", clientSecret: \"556df0480f8f48e142432f50273ea149cf206c07\", repo: \"FE-learning\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "},"doc/自动化部署的一小步，前端搬砖的一大步.html":{"url":"doc/自动化部署的一小步，前端搬砖的一大步.html","title":"自动化部署的一小步，前端搬砖的一大步","keywords":"","body":"在nodejs日渐普及的大背景下，前端工程化的发展可谓日新月异。构建打包这种日常任务脚本化已经是常态了，webpack和gulp已经家喻户晓自然不必多说，而持续集成/持续交付/持续部署也越来越得到各个前端Team的重视，业界也有了很多成熟的概念或者方案，如Hudson, Jenkins, Travis CI, Circle CI, DevOps, git hook。然而对于小白来讲，如果直接上手这些内容，很容易混淆概念，陷入迷茫。如果为了用Jenkins而用Jenkins，那不是我的做事风格，我必须搞清楚这项技术能给我带来什么。所以我干脆回归问题本质，从最简单的工作流入手，先解决手动部署的效率问题。 前面说这么多废话纯属凑字数，对了，本文讲的内容比较简单，不适合工作流已经很完善的同学 自动构建 构建不是本文的重点，也不是一篇短文能够讲清楚的，这里就一笔带过了。 构建工具 使用主流的构建工具如webpack, gulp, rollup等。 构建目标 通过脚本化的形式组织代码检查，编译，压缩，混淆，资源处理，devServer等工作流事务。 手动部署 踩过的坑 本人曾经也尝试过两种手动部署的方法。 搬砖模式，将构建完毕的文件夹通过xftp传输到服务器/usr/share/nginx/html目录下。 将构建完毕的文件夹用git分支管理起来，推送到远程仓库，然后在linux服务器上拉取这部分代码。 第一种方法显然已经属于刀耕火种模式了，不过我竟然用了很久。唉，没办法，业务缠身的我只能挤出时间来优化工作流。 第二种方法我自己私下也用过，后来一想，好像可以用git hook来改造优化下，也是实现自动部署的好方法。有兴趣的同学可以试试git hook。 自动部署 写脚本 先写个自动构建部署的脚本，主要是包含了切git分支，拉取最新代码，构建打包，传输文件到服务器这些步骤。 scp 命令用于 Linux 之间复制文件和目录 #!/bin/bash git checkout develop git pull npm run build:test scp -r ./dist/. username@162.81.49.85:/usr/share/nginx/html/projectname/ ps：ip已经被我胡乱改了一把，别试着攻击我了。 然而我发现在使用部署脚本的过程中，每次操作都要输入密码，很烦人。 ssh认证 虽然很讨厌输密码，但是密码是安全的保证，如果不输入密码，只能通过ssh安全访问了。 首先是在自己工作电脑的~/.ssh目录下创建密钥对。 ssh-keygen -t rsa 根据个人情况按需修改密钥对的文件名，输入密码时回车即可，代表不需要使用密码 接着要把公钥传输到服务器上 scp ~/.ssh/id_rsa.pub username@162.81.49.85:/home/username/.ssh/authorized_keys 如果服务器已经存在authorized_keys文件，那么可以直接在服务器上修改authorized_keys文件，在文件末加入你自己的id_rsa.pub内容即可。 然后我们再修改部署脚本，改用ssh认证方式向linux服务器传输文件。 #!/bin/bash git checkout develop npm run build:test scp -i ~/.ssh/id_rsa -r ./dist/. username@162.81.49.85:/usr/share/nginx/html/projectname/ scp的-i参数指定传输时使用的密钥文件，这样就可以通过ssh安全访问，而不用再每次输入密码了。-r参数则是recursive，代表递归复制整个目录。 最后我们可以修改下package.json，通过npm scripts来执行sh \"scripts\": { \"deploy:test\": \"deploy-test.sh\" } 配合vscode的npm scripts快捷方式，用起来就很舒服了。 注意，如果linux文件权限不够也可能报错的，别忘了给authorized_keys文件赋予权限，拥有者可读可写即可。 chmod 600 authorized_keys 好了，按下那个deploy:test，静静等待一会吧。此时别忘了扭扭脖子，按按腰啊，程序员还是要注意身体，对自己好一点。 随着bash窗口的自动关闭，部署工作也画上了句号。 last but not least 这里还要考虑的一个问题是，部署过程中会不会造成用户访问问题？ 答案是会影响用户访问。比如部署脚本执行过程中，已经替换了index.html，正在部署静态资源，此时用户正好进入网站，新的index.html却访问不到新的静态资源，网页白屏报错。 解决方法是先上静态资源，再上页面。因为静态资源经webpack构建后都带上了hash值，先上静态资源不会影响原有的版本，所以我们还需要再优化下部署脚本，分解下传输过程。 很头疼的是scp命令竟然不能忽略文件，这就有点麻烦了。 如果打包后的dist根目录文件不算很多，可以考虑手动列举的方式来排列传输顺序。举个例子： #!/bin/bash git checkout develop git pull npm run build:test scp -i ~/.ssh/id_rsa -r ./dist/static username@162.81.49.85:/usr/share/nginx/html/projectname/ scp -i ~/.ssh/id_rsa ./dist/favicon.ico username@162.81.49.85:/usr/share/nginx/html/projectname/favicon.ico scp -i ~/.ssh/id_rsa ./dist/element-icons.ttf username@162.81.49.85:/usr/share/nginx/html/projectname/element-icons.ttf scp -i ~/.ssh/id_rsa ./dist/element-icons.woff username@162.81.49.85:/usr/share/nginx/html/projectname/element-icons.woff scp -i ~/.ssh/id_rsa ./dist/index.html username@162.81.49.85:/usr/share/nginx/html/projectname/index.html 如果觉得这样很傻X，那么可以考虑下rsync了，rsync是可以通过--exclude忽略文件的，这样的话理论上只需要写两条传输命令即可，也不用考虑后续构建可能会新增的内容。不过在windows和linux之间用rsync还是蛮复杂的，留给各位大佬自己探索啦。 更新补充 2020-01-20 简化脚本 谢谢网友_shanks的提醒，可以用.ssh/config简化写法。首先是要修改.ssh/config # 配置开发环境 Host dev HostName 162.81.49.85 User username IdentityFile ~/.ssh/id_rsa 接着修改部署脚本deploy-test.sh #!/bin/bash git checkout develop git pull npm run build:test scp -r ./dist/static dev:/usr/share/nginx/html/projectname/ scp ./dist/favicon.ico dev:/usr/share/nginx/html/projectname/ scp ./dist/element-icons.ttf dev:/usr/share/nginx/html/projectname/ scp ./dist/element-icons.woff dev:/usr/share/nginx/html/projectname/ scp ./dist/index.html dev:/usr/share/nginx/html/projectname/ 我是Tusi，一个创业公司前端小leader，每天依然为写不完的业务代码烦恼，在打磨产品道路上沉淀技术，探索成长路线。如果你与我一样，正在思考自己的技术成长与价值，欢迎加我微信交流探讨，微信号ice_lloly。我会在公众号猿出道和小程序Tusi博客同步博客内容，快来撩我！ var gitalk = new Gitalk({ clientID: \"c17498a9a9fa6e17b36a\", clientSecret: \"556df0480f8f48e142432f50273ea149cf206c07\", repo: \"FE-learning\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "}}